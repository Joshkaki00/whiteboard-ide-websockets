[
  {
    "id": "1",
    "title": "Two Sum",
    "titleSlug": "two-sum",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 49.3,
    "topicTags": [
      "Array",
      "Hash Table"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 49.3%\n• Topics: Array, Hash Table\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "2",
    "title": "Add Two Numbers",
    "titleSlug": "add-two-numbers",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 41.5,
    "topicTags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "description": "Work through this linked list problem with pointer manipulation.\n\nTOPICS: Linked List, Math, Recursion\n\nKEY CONCEPTS:\n• Pointer manipulation\n• Dummy nodes\n• In-place vs new list\n• Null checks\n\nAPPROACH:\n1. Draw list on whiteboard\n2. Consider dummy head\n3. Track pointers carefully\n4. Test edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 41.5%\n• Topics: Linked List, Math, Recursion\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1] (if reversed) or relevant result",
        "explanation": "Draw: 1 -> 2 -> 3 -> 4 -> 5 -> null\nIf reversing: 5 -> 4 -> 3 -> 2 -> 1 -> null\nTrace pointer movements step by step!"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1] or relevant result",
        "explanation": "Two nodes: 1 -> 2 -> null. Simplest non-trivial case."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "Empty list returns null. Guard against null pointer errors!"
      }
    ],
    "constraints": [
      "0 <= list length <= 5000",
      "-1000 <= Node.val <= 1000",
      "List can be empty"
    ]
  },
  {
    "id": "3",
    "title": "Longest Substring Without Repeating Characters",
    "titleSlug": "longest-substring-without-repeating-characters",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 34.2,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Sliding Window\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 34.2%\n• Topics: Hash Table, String, Sliding Window\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "5",
    "title": "Longest Palindromic Substring",
    "titleSlug": "longest-palindromic-substring",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.1,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Dynamic Programming\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 33.1%\n• Topics: String, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "7",
    "title": "Reverse Integer",
    "titleSlug": "reverse-integer",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 28.5,
    "topicTags": [
      "Math"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Math\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 28.5%\n• Topics: Math\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "9",
    "title": "Palindrome Number",
    "titleSlug": "palindrome-number",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Math"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Math\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 54.2%\n• Topics: Math\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "11",
    "title": "Container With Most Water",
    "titleSlug": "container-with-most-water",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.8,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Two Pointers, Greedy\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 54.8%\n• Topics: Array, Two Pointers, Greedy\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "13",
    "title": "Roman to Integer",
    "titleSlug": "roman-to-integer",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.1,
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, Math, String\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 59.1%\n• Topics: Hash Table, Math, String\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "14",
    "title": "Longest Common Prefix",
    "titleSlug": "longest-common-prefix",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 42.3,
    "topicTags": [
      "String",
      "Trie"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Trie\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 42.3%\n• Topics: String, Trie\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "15",
    "title": "3Sum",
    "titleSlug": "3sum",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.5,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Two Pointers, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 33.5%\n• Topics: Array, Two Pointers, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "17",
    "title": "Letter Combinations of a Phone Number",
    "titleSlug": "letter-combinations-of-a-phone-number",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Backtracking\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 58.9%\n• Topics: Hash Table, String, Backtracking\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "19",
    "title": "Remove Nth Node From End of List",
    "titleSlug": "remove-nth-node-from-end-of-list",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.1,
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Linked List, Two Pointers\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 43.1%\n• Topics: Linked List, Two Pointers\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "20",
    "title": "Valid Parentheses",
    "titleSlug": "valid-parentheses",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 40.8,
    "topicTags": [
      "String",
      "Stack"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Stack\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 40.8%\n• Topics: String, Stack\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "21",
    "title": "Merge Two Sorted Lists",
    "titleSlug": "merge-two-sorted-lists",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 63.5,
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "description": "Work through this linked list problem with pointer manipulation.\n\nTOPICS: Linked List, Recursion\n\nKEY CONCEPTS:\n• Pointer manipulation\n• Dummy nodes\n• In-place vs new list\n• Null checks\n\nAPPROACH:\n1. Draw list on whiteboard\n2. Consider dummy head\n3. Track pointers carefully\n4. Test edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 63.5%\n• Topics: Linked List, Recursion\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1] (if reversed) or relevant result",
        "explanation": "Draw: 1 -> 2 -> 3 -> 4 -> 5 -> null\nIf reversing: 5 -> 4 -> 3 -> 2 -> 1 -> null\nTrace pointer movements step by step!"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1] or relevant result",
        "explanation": "Two nodes: 1 -> 2 -> null. Simplest non-trivial case."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "Empty list returns null. Guard against null pointer errors!"
      }
    ],
    "constraints": [
      "0 <= list length <= 5000",
      "-1000 <= Node.val <= 1000",
      "List can be empty"
    ]
  },
  {
    "id": "22",
    "title": "Generate Parentheses",
    "titleSlug": "generate-parentheses",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 73.9,
    "topicTags": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Dynamic Programming, Backtracking\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 73.9%\n• Topics: String, Dynamic Programming, Backtracking\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "23",
    "title": "Merge k Sorted Lists",
    "titleSlug": "merge-k-sorted-lists",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "description": "Work through this linked list problem with pointer manipulation.\n\nTOPICS: Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort\n\nKEY CONCEPTS:\n• Pointer manipulation\n• Dummy nodes\n• In-place vs new list\n• Null checks\n\nAPPROACH:\n1. Draw list on whiteboard\n2. Consider dummy head\n3. Track pointers carefully\n4. Test edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 51.8%\n• Topics: Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1] (if reversed) or relevant result",
        "explanation": "Draw: 1 -> 2 -> 3 -> 4 -> 5 -> null\nIf reversing: 5 -> 4 -> 3 -> 2 -> 1 -> null\nTrace pointer movements step by step!"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1] or relevant result",
        "explanation": "Two nodes: 1 -> 2 -> null. Simplest non-trivial case."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "Empty list returns null. Guard against null pointer errors!"
      }
    ],
    "constraints": [
      "0 <= list length <= 5000",
      "-1000 <= Node.val <= 1000",
      "List can be empty"
    ]
  },
  {
    "id": "26",
    "title": "Remove Duplicates from Sorted Array",
    "titleSlug": "remove-duplicates-from-sorted-array",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 53.4,
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Two Pointers\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 53.4%\n• Topics: Array, Two Pointers\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "33",
    "title": "Search in Rotated Sorted Array",
    "titleSlug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 40.1,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 40.1%\n• Topics: Array, Binary Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "34",
    "title": "Find First and Last Position of Element in Sorted Array",
    "titleSlug": "find-first-and-last-position-of-element-in-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.9,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 43.9%\n• Topics: Array, Binary Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "39",
    "title": "Combination Sum",
    "titleSlug": "combination-sum",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 71.2,
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Backtracking\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 71.2%\n• Topics: Array, Backtracking\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "42",
    "title": "Trapping Rain Water",
    "titleSlug": "trapping-rain-water",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 60.5,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 60.5%\n• Topics: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "46",
    "title": "Permutations",
    "titleSlug": "permutations",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 77.4,
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Backtracking\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 77.4%\n• Topics: Array, Backtracking\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "48",
    "title": "Rotate Image",
    "titleSlug": "rotate-image",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 72.8,
    "topicTags": [
      "Array",
      "Math",
      "Matrix"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Math, Matrix\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 72.8%\n• Topics: Array, Math, Matrix\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "49",
    "title": "Group Anagrams",
    "titleSlug": "group-anagrams",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 67.8,
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, String, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 67.8%\n• Topics: Array, Hash Table, String, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "53",
    "title": "Maximum Subarray",
    "titleSlug": "maximum-subarray",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.3,
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Divide and Conquer, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 50.3%\n• Topics: Array, Divide and Conquer, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "54",
    "title": "Spiral Matrix",
    "titleSlug": "spiral-matrix",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.8,
    "topicTags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Matrix, Simulation\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 46.8%\n• Topics: Array, Matrix, Simulation\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "55",
    "title": "Jump Game",
    "titleSlug": "jump-game",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 38.9,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming, Greedy\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 38.9%\n• Topics: Array, Dynamic Programming, Greedy\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "56",
    "title": "Merge Intervals",
    "titleSlug": "merge-intervals",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.9,
    "topicTags": [
      "Array",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 46.9%\n• Topics: Array, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "62",
    "title": "Unique Paths",
    "titleSlug": "unique-paths",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 63.9,
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "description": "Solve this DP problem by breaking it into subproblems.\n\nTOPICS: Math, Dynamic Programming, Combinatorics\n\nKEY CONCEPTS:\n• Overlapping subproblems\n• Optimal substructure\n• Memoization or tabulation\n• State definition\n\nAPPROACH:\n1. Define dp[i] meaning\n2. Find base cases\n3. Write recurrence relation\n4. Draw DP table on whiteboard!\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 63.9%\n• Topics: Math, Dynamic Programming, Combinatorics\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "n = 5",
        "output": "8 (example for Fibonacci-like problems)",
        "explanation": "If Fibonacci: dp = [0,1,1,2,3,5,8]. Draw the DP table showing how each value builds on previous ones."
      },
      {
        "input": "n = 3",
        "output": "3 or 5 (depends on problem)",
        "explanation": "Small input to trace through. dp[3] = some combination of dp[2] and dp[1]. Work it out!"
      },
      {
        "input": "n = 1",
        "output": "1 (base case)",
        "explanation": "Base case: dp[1] = 1. This is your starting point."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "Result fits in 32-bit integer",
      "May need O(n) space for DP table"
    ]
  },
  {
    "id": "70",
    "title": "Climbing Stairs",
    "titleSlug": "climbing-stairs",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 52.3,
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "description": "Solve this DP problem by breaking it into subproblems.\n\nTOPICS: Math, Dynamic Programming, Memoization\n\nKEY CONCEPTS:\n• Overlapping subproblems\n• Optimal substructure\n• Memoization or tabulation\n• State definition\n\nAPPROACH:\n1. Define dp[i] meaning\n2. Find base cases\n3. Write recurrence relation\n4. Draw DP table on whiteboard!\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 52.3%\n• Topics: Math, Dynamic Programming, Memoization\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "n = 5",
        "output": "8 (example for Fibonacci-like problems)",
        "explanation": "If Fibonacci: dp = [0,1,1,2,3,5,8]. Draw the DP table showing how each value builds on previous ones."
      },
      {
        "input": "n = 3",
        "output": "3 or 5 (depends on problem)",
        "explanation": "Small input to trace through. dp[3] = some combination of dp[2] and dp[1]. Work it out!"
      },
      {
        "input": "n = 1",
        "output": "1 (base case)",
        "explanation": "Base case: dp[1] = 1. This is your starting point."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "Result fits in 32-bit integer",
      "May need O(n) space for DP table"
    ]
  },
  {
    "id": "75",
    "title": "Sort Colors",
    "titleSlug": "sort-colors",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 60.9,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Two Pointers, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 60.9%\n• Topics: Array, Two Pointers, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "76",
    "title": "Minimum Window Substring",
    "titleSlug": "minimum-window-substring",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 41.7,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Sliding Window\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 41.7%\n• Topics: Hash Table, String, Sliding Window\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "78",
    "title": "Subsets",
    "titleSlug": "subsets",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 77.6,
    "topicTags": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Backtracking, Bit Manipulation\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 77.6%\n• Topics: Array, Backtracking, Bit Manipulation\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "79",
    "title": "Word Search",
    "titleSlug": "word-search",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 40.8,
    "topicTags": [
      "Array",
      "Backtracking",
      "Matrix"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Backtracking, Matrix\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 40.8%\n• Topics: Array, Backtracking, Matrix\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "84",
    "title": "Largest Rectangle in Histogram",
    "titleSlug": "largest-rectangle-in-histogram",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 43.5,
    "topicTags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Stack, Monotonic Stack\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 43.5%\n• Topics: Array, Stack, Monotonic Stack\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "91",
    "title": "Decode Ways",
    "titleSlug": "decode-ways",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.7,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Dynamic Programming\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 33.7%\n• Topics: String, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "94",
    "title": "Binary Tree Inorder Traversal",
    "titleSlug": "binary-tree-inorder-traversal",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.2,
    "topicTags": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Stack, Tree, Depth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 75.2%\n• Topics: Stack, Tree, Depth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "98",
    "title": "Validate Binary Search Tree",
    "titleSlug": "validate-binary-search-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 32.9,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 32.9%\n• Topics: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "100",
    "title": "Same Tree",
    "titleSlug": "same-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.8,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 59.8%\n• Topics: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "101",
    "title": "Symmetric Tree",
    "titleSlug": "symmetric-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 56.4,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 56.4%\n• Topics: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "102",
    "title": "Binary Tree Level Order Traversal",
    "titleSlug": "binary-tree-level-order-traversal",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.2,
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Breadth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 66.2%\n• Topics: Tree, Breadth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "104",
    "title": "Maximum Depth of Binary Tree",
    "titleSlug": "maximum-depth-of-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 75.1%\n• Topics: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "105",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "titleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 64.5,
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, Divide and Conquer, Tree, Binary Tree\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 64.5%\n• Topics: Array, Hash Table, Divide and Conquer, Tree, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "121",
    "title": "Best Time to Buy and Sell Stock",
    "titleSlug": "best-time-to-buy-and-sell-stock",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 54.2%\n• Topics: Array, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "124",
    "title": "Binary Tree Maximum Path Sum",
    "titleSlug": "binary-tree-maximum-path-sum",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 39.8,
    "topicTags": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this DP problem by breaking it into subproblems.\n\nTOPICS: Dynamic Programming, Tree, Depth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Overlapping subproblems\n• Optimal substructure\n• Memoization or tabulation\n• State definition\n\nAPPROACH:\n1. Define dp[i] meaning\n2. Find base cases\n3. Write recurrence relation\n4. Draw DP table on whiteboard!\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 39.8%\n• Topics: Dynamic Programming, Tree, Depth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "n = 5",
        "output": "8 (example for Fibonacci-like problems)",
        "explanation": "If Fibonacci: dp = [0,1,1,2,3,5,8]. Draw the DP table showing how each value builds on previous ones."
      },
      {
        "input": "n = 3",
        "output": "3 or 5 (depends on problem)",
        "explanation": "Small input to trace through. dp[3] = some combination of dp[2] and dp[1]. Work it out!"
      },
      {
        "input": "n = 1",
        "output": "1 (base case)",
        "explanation": "Base case: dp[1] = 1. This is your starting point."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "Result fits in 32-bit integer",
      "May need O(n) space for DP table"
    ]
  },
  {
    "id": "125",
    "title": "Valid Palindrome",
    "titleSlug": "valid-palindrome",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 45.9,
    "topicTags": [
      "Two Pointers",
      "String"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Two Pointers, String\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 45.9%\n• Topics: Two Pointers, String\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "128",
    "title": "Longest Consecutive Sequence",
    "titleSlug": "longest-consecutive-sequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 48.7,
    "topicTags": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, Union Find\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 48.7%\n• Topics: Array, Hash Table, Union Find\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "133",
    "title": "Clone Graph",
    "titleSlug": "clone-graph",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.9,
    "topicTags": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Hash Table, Depth-First Search, Breadth-First Search, Graph\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 54.9%\n• Topics: Hash Table, Depth-First Search, Breadth-First Search, Graph\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "139",
    "title": "Word Break",
    "titleSlug": "word-break",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.7,
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Trie",
      "Memoization"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, String, Dynamic Programming, Trie, Memoization\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 46.7%\n• Topics: Array, Hash Table, String, Dynamic Programming, Trie, Memoization\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "141",
    "title": "Linked List Cycle",
    "titleSlug": "linked-list-cycle",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 49.2,
    "topicTags": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Hash Table, Linked List, Two Pointers\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 49.2%\n• Topics: Hash Table, Linked List, Two Pointers\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "143",
    "title": "Reorder List",
    "titleSlug": "reorder-list",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 56.7,
    "topicTags": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Linked List, Two Pointers, Stack, Recursion\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 56.7%\n• Topics: Linked List, Two Pointers, Stack, Recursion\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "152",
    "title": "Maximum Product Subarray",
    "titleSlug": "maximum-product-subarray",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 35.1,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 35.1%\n• Topics: Array, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "153",
    "title": "Find Minimum in Rotated Sorted Array",
    "titleSlug": "find-minimum-in-rotated-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.3,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 50.3%\n• Topics: Array, Binary Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "198",
    "title": "House Robber",
    "titleSlug": "house-robber",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.2,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 50.2%\n• Topics: Array, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "200",
    "title": "Number of Islands",
    "titleSlug": "number-of-islands",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.1,
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Depth-First Search, Breadth-First Search, Union Find, Matrix\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 58.1%\n• Topics: Array, Depth-First Search, Breadth-First Search, Union Find, Matrix\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "206",
    "title": "Reverse Linked List",
    "titleSlug": "reverse-linked-list",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.4,
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "description": "Work through this linked list problem with pointer manipulation.\n\nTOPICS: Linked List, Recursion\n\nKEY CONCEPTS:\n• Pointer manipulation\n• Dummy nodes\n• In-place vs new list\n• Null checks\n\nAPPROACH:\n1. Draw list on whiteboard\n2. Consider dummy head\n3. Track pointers carefully\n4. Test edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 75.4%\n• Topics: Linked List, Recursion\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1] (if reversed) or relevant result",
        "explanation": "Draw: 1 -> 2 -> 3 -> 4 -> 5 -> null\nIf reversing: 5 -> 4 -> 3 -> 2 -> 1 -> null\nTrace pointer movements step by step!"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1] or relevant result",
        "explanation": "Two nodes: 1 -> 2 -> null. Simplest non-trivial case."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "Empty list returns null. Guard against null pointer errors!"
      }
    ],
    "constraints": [
      "0 <= list length <= 5000",
      "-1000 <= Node.val <= 1000",
      "List can be empty"
    ]
  },
  {
    "id": "207",
    "title": "Course Schedule",
    "titleSlug": "course-schedule",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.5,
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Depth-First Search, Breadth-First Search, Graph, Topological Sort\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 46.5%\n• Topics: Depth-First Search, Breadth-First Search, Graph, Topological Sort\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "208",
    "title": "Implement Trie (Prefix Tree)",
    "titleSlug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 65.4,
    "topicTags": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Design, Trie\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 65.4%\n• Topics: Hash Table, String, Design, Trie\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "210",
    "title": "Course Schedule II",
    "titleSlug": "course-schedule-ii",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 48.9,
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Depth-First Search, Breadth-First Search, Graph, Topological Sort\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 48.9%\n• Topics: Depth-First Search, Breadth-First Search, Graph, Topological Sort\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "212",
    "title": "Word Search II",
    "titleSlug": "word-search-ii",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 37.8,
    "topicTags": [
      "Array",
      "String",
      "Backtracking",
      "Trie",
      "Matrix"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, String, Backtracking, Trie, Matrix\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 37.8%\n• Topics: Array, String, Backtracking, Trie, Matrix\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "215",
    "title": "Kth Largest Element in an Array",
    "titleSlug": "kth-largest-element-in-an-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 67.2,
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 67.2%\n• Topics: Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "217",
    "title": "Contains Duplicate",
    "titleSlug": "contains-duplicate",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 61.8,
    "topicTags": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 61.8%\n• Topics: Array, Hash Table, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "226",
    "title": "Invert Binary Tree",
    "titleSlug": "invert-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.9,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 75.9%\n• Topics: Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "230",
    "title": "Kth Smallest Element in a BST",
    "titleSlug": "kth-smallest-element-in-a-bst",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 72.5,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 72.5%\n• Topics: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "234",
    "title": "Palindrome Linked List",
    "titleSlug": "palindrome-linked-list",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Linked List, Two Pointers, Stack, Recursion\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 51.8%\n• Topics: Linked List, Two Pointers, Stack, Recursion\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "235",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 63.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 63.1%\n• Topics: Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "236",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "titleSlug": "lowest-common-ancestor-of-a-binary-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 60.5,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 60.5%\n• Topics: Tree, Depth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "238",
    "title": "Product of Array Except Self",
    "titleSlug": "product-of-array-except-self",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.2,
    "topicTags": [
      "Array",
      "Prefix Sum"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Prefix Sum\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 66.2%\n• Topics: Array, Prefix Sum\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "242",
    "title": "Valid Anagram",
    "titleSlug": "valid-anagram",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 63.8,
    "topicTags": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Hash Table, String, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 63.8%\n• Topics: Hash Table, String, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "268",
    "title": "Missing Number",
    "titleSlug": "missing-number",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 64.3,
    "topicTags": [
      "Array",
      "Hash Table",
      "Math",
      "Bit Manipulation",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, Math, Bit Manipulation, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 64.3%\n• Topics: Array, Hash Table, Math, Bit Manipulation, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "295",
    "title": "Find Median from Data Stream",
    "titleSlug": "find-median-from-data-stream",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Two Pointers",
      "Design",
      "Sorting",
      "Heap (Priority Queue)",
      "Data Stream"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Two Pointers, Design, Sorting, Heap (Priority Queue), Data Stream\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 51.8%\n• Topics: Two Pointers, Design, Sorting, Heap (Priority Queue), Data Stream\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "297",
    "title": "Serialize and Deserialize Binary Tree",
    "titleSlug": "serialize-and-deserialize-binary-tree",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 57.2,
    "topicTags": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Tree\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Hard\n• Acceptance Rate: 57.2%\n• Topics: String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "300",
    "title": "Longest Increasing Subsequence",
    "titleSlug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 54.2%\n• Topics: Array, Binary Search, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "322",
    "title": "Coin Change",
    "titleSlug": "coin-change",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.9,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming, Breadth-First Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 43.9%\n• Topics: Array, Dynamic Programming, Breadth-First Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "347",
    "title": "Top K Frequent Elements",
    "titleSlug": "top-k-frequent-elements",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 65.1,
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 65.1%\n• Topics: Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "371",
    "title": "Sum of Two Integers",
    "titleSlug": "sum-of-two-integers",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.8,
    "topicTags": [
      "Math",
      "Bit Manipulation"
    ],
    "description": "Solve this problem using appropriate algorithms and data structures.\n\nTOPICS: Math, Bit Manipulation\n\nAPPROACH:\n1. Understand the problem\n2. Draw examples\n3. Find patterns\n4. Code solution\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 50.8%\n• Topics: Math, Bit Manipulation\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Input example 1",
        "output": "Expected output 1",
        "explanation": "Work through this example on the whiteboard step by step."
      },
      {
        "input": "Input example 2",
        "output": "Expected output 2",
        "explanation": "Another test case to verify your approach."
      }
    ],
    "constraints": [
      "See problem constraints",
      "Consider edge cases",
      "Think about time/space complexity"
    ]
  },
  {
    "id": "417",
    "title": "Pacific Atlantic Water Flow",
    "titleSlug": "pacific-atlantic-water-flow",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 55.1,
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Depth-First Search, Breadth-First Search, Matrix\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 55.1%\n• Topics: Array, Depth-First Search, Breadth-First Search, Matrix\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "424",
    "title": "Longest Repeating Character Replacement",
    "titleSlug": "longest-repeating-character-replacement",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 52.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Sliding Window\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 52.9%\n• Topics: Hash Table, String, Sliding Window\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "435",
    "title": "Non-overlapping Intervals",
    "titleSlug": "non-overlapping-intervals",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 51.7,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming, Greedy, Sorting\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 51.7%\n• Topics: Array, Dynamic Programming, Greedy, Sorting\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "449",
    "title": "Serialize and Deserialize BST",
    "titleSlug": "serialize-and-deserialize-bst",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.7,
    "topicTags": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Search Tree, Binary Tree\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 58.7%\n• Topics: String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Search Tree, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "518",
    "title": "Coin Change II",
    "titleSlug": "coin-change-ii",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 64.8,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Dynamic Programming\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 64.8%\n• Topics: Array, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "543",
    "title": "Diameter of Binary Tree",
    "titleSlug": "diameter-of-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 58.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Solve this tree problem using traversal and recursion.\n\nTOPICS: Tree, Depth-First Search, Binary Tree\n\nKEY CONCEPTS:\n• Tree traversal (DFS/BFS)\n• Recursion with base cases\n• Left and right subtrees\n• Null checks\n\nAPPROACH:\n1. Draw tree on whiteboard\n2. Identify base case (null)\n3. Define what to return\n4. Test with examples\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 58.1%\n• Topics: Tree, Depth-First Search, Binary Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1] (if inverted) or relevant result",
        "explanation": "Tree structure:\n       4\n      / \\\n     2   7\n    / \\ / \\\n   1  3 6  9\nDraw this and trace your algorithm!"
      },
      {
        "input": "root = [2,1,3]",
        "output": "3 (if max depth) or relevant result",
        "explanation": "Simple 3-node tree. Height = 2. Test your recursion logic."
      },
      {
        "input": "root = []",
        "output": "null or 0",
        "explanation": "Empty tree edge case. What does your function return?"
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10⁴",
      "-1000 <= Node.val <= 1000",
      "Tree can be empty"
    ]
  },
  {
    "id": "572",
    "title": "Subtree of Another Tree",
    "titleSlug": "subtree-of-another-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 47.2,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "String Matching",
      "Binary Tree",
      "Hash Function"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Tree, Depth-First Search, String Matching, Binary Tree, Hash Function\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 47.2%\n• Topics: Tree, Depth-First Search, String Matching, Binary Tree, Hash Function\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "647",
    "title": "Palindromic Substrings",
    "titleSlug": "palindromic-substrings",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 68.3,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Dynamic Programming\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 68.3%\n• Topics: String, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "704",
    "title": "Binary Search",
    "titleSlug": "binary-search",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.7,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 59.7%\n• Topics: Array, Binary Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "739",
    "title": "Daily Temperatures",
    "titleSlug": "daily-temperatures",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.8,
    "topicTags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Stack, Monotonic Stack\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 66.8%\n• Topics: Array, Stack, Monotonic Stack\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "853",
    "title": "Car Fleet",
    "titleSlug": "car-fleet",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.1,
    "topicTags": [
      "Array",
      "Stack",
      "Sorting",
      "Monotonic Stack"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Stack, Sorting, Monotonic Stack\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 50.1%\n• Topics: Array, Stack, Sorting, Monotonic Stack\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "875",
    "title": "Koko Eating Bananas",
    "titleSlug": "koko-eating-bananas",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 55.7,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Binary Search\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 55.7%\n• Topics: Array, Binary Search\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "981",
    "title": "Time Based Key-Value Store",
    "titleSlug": "time-based-key-value-store",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 53.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Binary Search",
      "Design"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: Hash Table, String, Binary Search, Design\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 53.9%\n• Topics: Hash Table, String, Binary Search, Design\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "1046",
    "title": "Last Stone Weight",
    "titleSlug": "last-stone-weight",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 65.3,
    "topicTags": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Heap (Priority Queue)\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Easy\n• Acceptance Rate: 65.3%\n• Topics: Array, Heap (Priority Queue)\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  },
  {
    "id": "1143",
    "title": "Longest Common Subsequence",
    "titleSlug": "longest-common-subsequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.9,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Work through this string problem using efficient traversal techniques.\n\nTOPICS: String, Dynamic Programming\n\nKEY CONCEPTS:\n• String traversal patterns\n• Character frequency counting\n• Two pointers or sliding window\n• String immutability\n\nAPPROACH:\n1. Write examples on whiteboard\n2. Look for patterns\n3. Consider hash maps for frequency\n4. Think about edge cases\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 58.9%\n• Topics: String, Dynamic Programming\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "s = \"racecar\"",
        "output": "true (if palindrome check) or relevant result",
        "explanation": "Palindrome example - reads same forwards and backwards. Draw pointers moving from both ends."
      },
      {
        "input": "s = \"hello\"",
        "output": "Result based on problem",
        "explanation": "Regular string with distinct characters. Trace through your algorithm character by character."
      },
      {
        "input": "s = \"a\"",
        "output": "true or single char result",
        "explanation": "Single character is always valid for most string operations."
      }
    ],
    "constraints": [
      "0 <= s.length <= 10⁵",
      "s consists of lowercase/uppercase letters",
      "May contain spaces or special characters"
    ]
  },
  {
    "id": "1584",
    "title": "Min Cost to Connect All Points",
    "titleSlug": "min-cost-to-connect-all-points",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 70.5,
    "topicTags": [
      "Array",
      "Union Find",
      "Graph",
      "Minimum Spanning Tree"
    ],
    "description": "Solve this array problem efficiently using the right data structures and algorithms.\n\nTOPICS: Array, Union Find, Graph, Minimum Spanning Tree\n\nKEY CONCEPTS:\n• Array traversal and indexing\n• Time/space complexity\n• Edge case handling\n\nAPPROACH:\n1. Understand input/output format\n2. Consider edge cases\n3. Draw examples on whiteboard\n4. Think about optimization\n\n📊 PROBLEM STATS:\n• Difficulty: Medium\n• Acceptance Rate: 70.5%\n• Topics: Array, Union Find, Graph, Minimum Spanning Tree\n\n🎨 INTERVIEW TIP:\nUse the whiteboard to:\n• Sketch out your approach\n• Draw examples and edge cases\n• Explain your thinking to your interviewer\n• Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "nums = [5, 2, 8, 1, 9]",
        "output": "[1, 2, 5, 8, 9] (or depends on problem)",
        "explanation": "Trace through your algorithm with this example. What happens at each step?"
      },
      {
        "input": "nums = [1]",
        "output": "[1] or single element result",
        "explanation": "Single element - does your algorithm handle this correctly?"
      },
      {
        "input": "nums = []",
        "output": "[] or appropriate empty result",
        "explanation": "Empty array edge case - what should be returned?"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ <= nums[i] <= 10⁴",
      "All elements may or may not be unique"
    ]
  }
]