[
  {
    "id": "1",
    "title": "Two Sum",
    "titleSlug": "two-sum",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 49.3,
    "topicTags": [
      "Array",
      "Hash Table"
    ],
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10⁴",
      "-10⁹ <= nums[i] <= 10⁹",
      "-10⁹ <= target <= 10⁹",
      "Only one valid answer exists."
    ]
  },
  {
    "id": "20",
    "title": "Valid Parentheses",
    "titleSlug": "valid-parentheses",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 40.8,
    "topicTags": [
      "String",
      "Stack"
    ],
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "The string has matching parentheses."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets are properly closed and in the correct order."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched bracket types."
      },
      {
        "input": "s = \"([)]\"",
        "output": "false",
        "explanation": "Brackets are not closed in the correct order."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10⁴",
      "s consists of parentheses only '()[]{}'"
    ]
  },
  {
    "id": "21",
    "title": "Merge Two Sorted Lists",
    "titleSlug": "merge-two-sorted-lists",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 63.5,
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "The merged list contains all elements in sorted order."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "First list is empty, return second list."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order"
    ]
  },
  {
    "id": "121",
    "title": "Best Time to Buy and Sell Stock",
    "titleSlug": "best-time-to-buy-and-sell-stock",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given an array prices where prices[i] is the price of a given stock on the iᵗʰ day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10⁵",
      "0 <= prices[i] <= 10⁴"
    ]
  },
  {
    "id": "125",
    "title": "Valid Palindrome",
    "titleSlug": "valid-palindrome",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 45.9,
    "topicTags": [
      "Two Pointers",
      "String"
    ],
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" is not a palindrome."
      },
      {
        "input": "s = \" \"",
        "output": "true",
        "explanation": "s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome."
      }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10⁵",
      "s consists only of printable ASCII characters"
    ]
  },
  {
    "id": "206",
    "title": "Reverse Linked List",
    "titleSlug": "reverse-linked-list",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.4,
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The list is reversed from 1->2->3->4->5 to 5->4->3->2->1."
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": "The two-node list is reversed."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "Empty list remains empty."
      }
    ],
    "constraints": [
      "The number of nodes in the list is the range [0, 5000]",
      "-5000 <= Node.val <= 5000"
    ]
  },
  {
    "id": "226",
    "title": "Invert Binary Tree",
    "titleSlug": "invert-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.9,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping the left and right children of every node in the tree.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]",
        "explanation": "The tree is inverted by swapping left and right children at every level."
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,3,1]",
        "explanation": "Simple inversion of a three-node tree."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree remains empty."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 <= Node.val <= 100"
    ]
  },
  {
    "id": "242",
    "title": "Valid Anagram",
    "titleSlug": "valid-anagram",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 63.8,
    "topicTags": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "Both strings contain the same characters with the same frequencies."
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false",
        "explanation": "The strings have different characters."
      }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10⁴",
      "s and t consist of lowercase English letters"
    ]
  },
  {
    "id": "704",
    "title": "Binary Search",
    "titleSlug": "binary-search",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.7,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [-1,0,3,5,9,12], target = 9",
        "output": "4",
        "explanation": "9 exists in nums and its index is 4."
      },
      {
        "input": "nums = [-1,0,3,5,9,12], target = 2",
        "output": "-1",
        "explanation": "2 does not exist in nums so return -1."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁴",
      "-10⁴ < nums[i], target < 10⁴",
      "All the integers in nums are unique",
      "nums is sorted in ascending order"
    ]
  },
  {
    "id": "3",
    "title": "Longest Substring Without Repeating Characters",
    "titleSlug": "longest-substring-without-repeating-characters",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 34.2,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring."
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 10⁴",
      "s consists of English letters, digits, symbols and spaces"
    ]
  },
  {
    "id": "15",
    "title": "3Sum",
    "titleSlug": "3sum",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.5,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2]."
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": "The only possible triplet does not sum up to 0."
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]",
        "explanation": "The only possible triplet sums up to 0."
      }
    ],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-10⁵ <= nums[i] <= 10⁵"
    ]
  },
  {
    "id": "49",
    "title": "Group Anagrams",
    "titleSlug": "group-anagrams",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 67.8,
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "The strings are grouped by their sorted character sequences."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Single empty string forms one group."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Single character string forms one group."
      }
    ],
    "constraints": [
      "1 <= strs.length <= 10⁴",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters"
    ]
  },
  {
    "id": "53",
    "title": "Maximum Subarray",
    "titleSlug": "maximum-subarray",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.3,
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁵",
      "-10⁴ <= nums[i] <= 10⁴"
    ]
  },
  {
    "id": "56",
    "title": "Merge Intervals",
    "titleSlug": "merge-intervals",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.9,
    "topicTags": [
      "Array",
      "Sorting"
    ],
    "description": "Given an array of intervals where intervals[i] = [startᵢ, endᵢ], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
      }
    ],
    "constraints": [
      "1 <= intervals.length <= 10⁴",
      "intervals[i].length == 2",
      "0 <= startᵢ <= endᵢ <= 10⁴"
    ]
  },
  {
    "id": "70",
    "title": "Climbing Stairs",
    "titleSlug": "climbing-stairs",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 52.3,
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1. 1 step + 1 step + 1 step, 2. 1 step + 2 steps, 3. 2 steps + 1 step."
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ]
  },
  {
    "id": "104",
    "title": "Maximum Depth of Binary Tree",
    "titleSlug": "maximum-depth-of-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The tree has a maximum depth of 3."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The tree has a maximum depth of 2."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10⁴]",
      "-100 <= Node.val <= 100"
    ]
  },
  {
    "id": "141",
    "title": "Linked List Cycle",
    "titleSlug": "linked-list-cycle",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 49.2,
    "topicTags": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "constraints": [
      "The number of the nodes in the list is in the range [0, 10⁴]",
      "-10⁵ <= Node.val <= 10⁵",
      "pos is -1 or a valid index in the linked-list"
    ]
  },
  {
    "id": "200",
    "title": "Number of Islands",
    "titleSlug": "number-of-islands",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.1,
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
      {
        "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
        "output": "1",
        "explanation": "There is one island formed by the connected '1's."
      },
      {
        "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "output": "3",
        "explanation": "There are three separate islands."
      }
    ],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'"
    ]
  },
  {
    "id": "217",
    "title": "Contains Duplicate",
    "titleSlug": "contains-duplicate",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 61.8,
    "topicTags": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": "The value 1 appears twice."
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": "All elements are distinct."
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true",
        "explanation": "Multiple values appear more than once."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10⁵",
      "-10⁹ <= nums[i] <= 10⁹"
    ]
  },
  {
    "id": "238",
    "title": "Product of Array Except Self",
    "titleSlug": "product-of-array-except-self",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.2,
    "topicTags": [
      "Array",
      "Prefix Sum"
    ],
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]",
        "explanation": "The zero makes most products zero."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10⁵",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer"
    ]
  },
  {
    "id": "7",
    "title": "Reverse Integer",
    "titleSlug": "reverse-integer",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 28.5,
    "topicTags": [
      "Math"
    ],
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2³¹, 2³¹ - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "The digits are reversed from 123 to 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "Negative sign is preserved while reversing digits."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "Trailing zeros are removed after reversal."
      }
    ],
    "constraints": [
      "-2³¹ <= x <= 2³¹ - 1"
    ]
  },
  {
    "id": "62",
    "title": "Unique Paths",
    "titleSlug": "unique-paths",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 63.9,
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated so that the answer will be less than or equal to 2 × 10⁹.",
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths from top-left to bottom-right."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "From top-left corner, there are 3 ways to reach bottom-right: 1. Right -> Down -> Down, 2. Down -> Down -> Right, 3. Down -> Right -> Down"
      }
    ],
    "constraints": [
      "1 <= m, n <= 100"
    ]
  },
  {
    "id": "198",
    "title": "House Robber",
    "titleSlug": "house-robber",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.2,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ]
  },
  {
    "id": "207",
    "title": "Course Schedule",
    "titleSlug": "course-schedule",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.5,
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [aᵢ, bᵢ] indicates that you must take course bᵢ first if you want to take course aᵢ.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
      }
    ],
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= aᵢ, bᵢ < numCourses",
      "All the pairs prerequisites[i] are unique"
    ]
  },
  {
    "id": "322",
    "title": "Coin Change",
    "titleSlug": "coin-change",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.9,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "examples": [
      {
        "input": "coins = [1,2,5], amount = 11",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "Amount 3 cannot be made with only coins of denomination 2."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "Zero coins are needed for amount 0."
      }
    ],
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2³¹ - 1",
      "0 <= amount <= 10⁴"
    ]
  },
  {
    "id": "2",
    "title": "Add Two Numbers",
    "titleSlug": "add-two-numbers",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 41.5,
    "topicTags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "description": "# Add Two Numbers\n\nWork through this linked list problem using pointer manipulation and careful traversal.\n\n**Key Concepts:**\n- Pointer manipulation (slow/fast, previous/current)\n- Dummy nodes for easier edge case handling\n- In-place vs new list creation\n- Cycle detection techniques\n\n**Approach:**\n1. Draw the linked list on the whiteboard\n2. Consider using a dummy head\n3. Track multiple pointers if needed\n4. Watch for null pointer issues\n5. Test with edge cases (empty, single node)\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 41.5%\n- **Topics:** Linked List, Math, Recursion\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for linked list structure",
        "output": "See problem for expected output",
        "explanation": "Draw the pointer movements on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: list length, node value ranges, list can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "5",
    "title": "Longest Palindromic Substring",
    "titleSlug": "longest-palindromic-substring",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.1,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "# Longest Palindromic Substring\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 33.1%\n- **Topics:** String, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "9",
    "title": "Palindrome Number",
    "titleSlug": "palindrome-number",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Math"
    ],
    "description": "# Palindrome Number\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 54.2%\n- **Topics:** Math\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "11",
    "title": "Container With Most Water",
    "titleSlug": "container-with-most-water",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.8,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "description": "# Container With Most Water\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 54.8%\n- **Topics:** Array, Two Pointers, Greedy\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "13",
    "title": "Roman to Integer",
    "titleSlug": "roman-to-integer",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.1,
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "description": "# Roman to Integer\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 59.1%\n- **Topics:** Hash Table, Math, String\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "14",
    "title": "Longest Common Prefix",
    "titleSlug": "longest-common-prefix",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 42.3,
    "topicTags": [
      "String",
      "Trie"
    ],
    "description": "# Longest Common Prefix\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 42.3%\n- **Topics:** String, Trie\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "17",
    "title": "Letter Combinations of a Phone Number",
    "titleSlug": "letter-combinations-of-a-phone-number",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "description": "# Letter Combinations of a Phone Number\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 58.9%\n- **Topics:** Hash Table, String, Backtracking\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "19",
    "title": "Remove Nth Node From End of List",
    "titleSlug": "remove-nth-node-from-end-of-list",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.1,
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "# Remove Nth Node From End of List\n\nWork through this linked list problem using pointer manipulation and careful traversal.\n\n**Key Concepts:**\n- Pointer manipulation (slow/fast, previous/current)\n- Dummy nodes for easier edge case handling\n- In-place vs new list creation\n- Cycle detection techniques\n\n**Approach:**\n1. Draw the linked list on the whiteboard\n2. Consider using a dummy head\n3. Track multiple pointers if needed\n4. Watch for null pointer issues\n5. Test with edge cases (empty, single node)\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 43.1%\n- **Topics:** Linked List, Two Pointers\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for linked list structure",
        "output": "See problem for expected output",
        "explanation": "Draw the pointer movements on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: list length, node value ranges, list can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "22",
    "title": "Generate Parentheses",
    "titleSlug": "generate-parentheses",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 73.9,
    "topicTags": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "description": "# Generate Parentheses\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 73.9%\n- **Topics:** String, Dynamic Programming, Backtracking\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "23",
    "title": "Merge k Sorted Lists",
    "titleSlug": "merge-k-sorted-lists",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "description": "# Merge k Sorted Lists\n\nWork through this linked list problem using pointer manipulation and careful traversal.\n\n**Key Concepts:**\n- Pointer manipulation (slow/fast, previous/current)\n- Dummy nodes for easier edge case handling\n- In-place vs new list creation\n- Cycle detection techniques\n\n**Approach:**\n1. Draw the linked list on the whiteboard\n2. Consider using a dummy head\n3. Track multiple pointers if needed\n4. Watch for null pointer issues\n5. Test with edge cases (empty, single node)\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 51.8%\n- **Topics:** Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for linked list structure",
        "output": "See problem for expected output",
        "explanation": "Draw the pointer movements on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: list length, node value ranges, list can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "26",
    "title": "Remove Duplicates from Sorted Array",
    "titleSlug": "remove-duplicates-from-sorted-array",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 53.4,
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "description": "# Remove Duplicates from Sorted Array\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 53.4%\n- **Topics:** Array, Two Pointers\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "33",
    "title": "Search in Rotated Sorted Array",
    "titleSlug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 40.1,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "# Search in Rotated Sorted Array\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 40.1%\n- **Topics:** Array, Binary Search\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "34",
    "title": "Find First and Last Position of Element in Sorted Array",
    "titleSlug": "find-first-and-last-position-of-element-in-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 43.9,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "# Find First and Last Position of Element in Sorted Array\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 43.9%\n- **Topics:** Array, Binary Search\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "39",
    "title": "Combination Sum",
    "titleSlug": "combination-sum",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 71.2,
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "description": "# Combination Sum\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 71.2%\n- **Topics:** Array, Backtracking\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "42",
    "title": "Trapping Rain Water",
    "titleSlug": "trapping-rain-water",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 60.5,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "# Trapping Rain Water\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 60.5%\n- **Topics:** Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "46",
    "title": "Permutations",
    "titleSlug": "permutations",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 77.4,
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "description": "# Permutations\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 77.4%\n- **Topics:** Array, Backtracking\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "48",
    "title": "Rotate Image",
    "titleSlug": "rotate-image",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 72.8,
    "topicTags": [
      "Array",
      "Math",
      "Matrix"
    ],
    "description": "# Rotate Image\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 72.8%\n- **Topics:** Array, Math, Matrix\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "54",
    "title": "Spiral Matrix",
    "titleSlug": "spiral-matrix",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.8,
    "topicTags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "description": "# Spiral Matrix\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 46.8%\n- **Topics:** Array, Matrix, Simulation\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "55",
    "title": "Jump Game",
    "titleSlug": "jump-game",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 38.9,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "description": "# Jump Game\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 38.9%\n- **Topics:** Array, Dynamic Programming, Greedy\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "75",
    "title": "Sort Colors",
    "titleSlug": "sort-colors",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 60.9,
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "# Sort Colors\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 60.9%\n- **Topics:** Array, Two Pointers, Sorting\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "76",
    "title": "Minimum Window Substring",
    "titleSlug": "minimum-window-substring",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 41.7,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "# Minimum Window Substring\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 41.7%\n- **Topics:** Hash Table, String, Sliding Window\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "78",
    "title": "Subsets",
    "titleSlug": "subsets",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 77.6,
    "topicTags": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "description": "# Subsets\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 77.6%\n- **Topics:** Array, Backtracking, Bit Manipulation\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "79",
    "title": "Word Search",
    "titleSlug": "word-search",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 40.8,
    "topicTags": [
      "Array",
      "Backtracking",
      "Matrix"
    ],
    "description": "# Word Search\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 40.8%\n- **Topics:** Array, Backtracking, Matrix\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "84",
    "title": "Largest Rectangle in Histogram",
    "titleSlug": "largest-rectangle-in-histogram",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 43.5,
    "topicTags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "# Largest Rectangle in Histogram\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 43.5%\n- **Topics:** Array, Stack, Monotonic Stack\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "91",
    "title": "Decode Ways",
    "titleSlug": "decode-ways",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 33.7,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "# Decode Ways\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 33.7%\n- **Topics:** String, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "94",
    "title": "Binary Tree Inorder Traversal",
    "titleSlug": "binary-tree-inorder-traversal",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 75.2,
    "topicTags": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "# Binary Tree Inorder Traversal\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 75.2%\n- **Topics:** Stack, Tree, Depth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "98",
    "title": "Validate Binary Search Tree",
    "titleSlug": "validate-binary-search-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 32.9,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "# Validate Binary Search Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 32.9%\n- **Topics:** Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "100",
    "title": "Same Tree",
    "titleSlug": "same-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 59.8,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "# Same Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 59.8%\n- **Topics:** Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "101",
    "title": "Symmetric Tree",
    "titleSlug": "symmetric-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 56.4,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "# Symmetric Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 56.4%\n- **Topics:** Tree, Depth-First Search, Breadth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "102",
    "title": "Binary Tree Level Order Traversal",
    "titleSlug": "binary-tree-level-order-traversal",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.2,
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "# Binary Tree Level Order Traversal\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 66.2%\n- **Topics:** Tree, Breadth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "105",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "titleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 64.5,
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "description": "# Construct Binary Tree from Preorder and Inorder Traversal\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 64.5%\n- **Topics:** Array, Hash Table, Divide and Conquer, Tree, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "124",
    "title": "Binary Tree Maximum Path Sum",
    "titleSlug": "binary-tree-maximum-path-sum",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 39.8,
    "topicTags": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "# Binary Tree Maximum Path Sum\n\nThis dynamic programming problem tests your ability to break problems into subproblems and build solutions incrementally.\n\n**Key Concepts:**\n- Overlapping subproblems\n- Optimal substructure\n- Memoization (top-down) vs Tabulation (bottom-up)\n- State definition and transitions\n\n**Approach:**\n1. Define what dp[i] represents\n2. Find the base cases\n3. Write the recurrence relation\n4. Decide: recursive with memo or iterative?\n5. Draw the dp table on the whiteboard!\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 39.8%\n- **Topics:** Dynamic Programming, Tree, Depth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the DP table and trace through small examples!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "DP problems often have constraints like: n <= 1000, values within certain ranges",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "128",
    "title": "Longest Consecutive Sequence",
    "titleSlug": "longest-consecutive-sequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 48.7,
    "topicTags": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "description": "# Longest Consecutive Sequence\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 48.7%\n- **Topics:** Array, Hash Table, Union Find\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "133",
    "title": "Clone Graph",
    "titleSlug": "clone-graph",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.9,
    "topicTags": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "description": "# Clone Graph\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 54.9%\n- **Topics:** Hash Table, Depth-First Search, Breadth-First Search, Graph\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "139",
    "title": "Word Break",
    "titleSlug": "word-break",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 46.7,
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Trie",
      "Memoization"
    ],
    "description": "# Word Break\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 46.7%\n- **Topics:** Array, Hash Table, String, Dynamic Programming, Trie, Memoization\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "143",
    "title": "Reorder List",
    "titleSlug": "reorder-list",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 56.7,
    "topicTags": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "# Reorder List\n\nWork through this linked list problem using pointer manipulation and careful traversal.\n\n**Key Concepts:**\n- Pointer manipulation (slow/fast, previous/current)\n- Dummy nodes for easier edge case handling\n- In-place vs new list creation\n- Cycle detection techniques\n\n**Approach:**\n1. Draw the linked list on the whiteboard\n2. Consider using a dummy head\n3. Track multiple pointers if needed\n4. Watch for null pointer issues\n5. Test with edge cases (empty, single node)\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 56.7%\n- **Topics:** Linked List, Two Pointers, Stack, Recursion\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for linked list structure",
        "output": "See problem for expected output",
        "explanation": "Draw the pointer movements on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: list length, node value ranges, list can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "152",
    "title": "Maximum Product Subarray",
    "titleSlug": "maximum-product-subarray",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 35.1,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "# Maximum Product Subarray\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 35.1%\n- **Topics:** Array, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "153",
    "title": "Find Minimum in Rotated Sorted Array",
    "titleSlug": "find-minimum-in-rotated-sorted-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.3,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "# Find Minimum in Rotated Sorted Array\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 50.3%\n- **Topics:** Array, Binary Search\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "208",
    "title": "Implement Trie (Prefix Tree)",
    "titleSlug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 65.4,
    "topicTags": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "description": "# Implement Trie (Prefix Tree)\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 65.4%\n- **Topics:** Hash Table, String, Design, Trie\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "210",
    "title": "Course Schedule II",
    "titleSlug": "course-schedule-ii",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 48.9,
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "# Course Schedule II\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 48.9%\n- **Topics:** Depth-First Search, Breadth-First Search, Graph, Topological Sort\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "212",
    "title": "Word Search II",
    "titleSlug": "word-search-ii",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 37.8,
    "topicTags": [
      "Array",
      "String",
      "Backtracking",
      "Trie",
      "Matrix"
    ],
    "description": "# Word Search II\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 37.8%\n- **Topics:** Array, String, Backtracking, Trie, Matrix\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "215",
    "title": "Kth Largest Element in an Array",
    "titleSlug": "kth-largest-element-in-an-array",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 67.2,
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "description": "# Kth Largest Element in an Array\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 67.2%\n- **Topics:** Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "230",
    "title": "Kth Smallest Element in a BST",
    "titleSlug": "kth-smallest-element-in-a-bst",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 72.5,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "# Kth Smallest Element in a BST\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 72.5%\n- **Topics:** Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "234",
    "title": "Palindrome Linked List",
    "titleSlug": "palindrome-linked-list",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "# Palindrome Linked List\n\nWork through this linked list problem using pointer manipulation and careful traversal.\n\n**Key Concepts:**\n- Pointer manipulation (slow/fast, previous/current)\n- Dummy nodes for easier edge case handling\n- In-place vs new list creation\n- Cycle detection techniques\n\n**Approach:**\n1. Draw the linked list on the whiteboard\n2. Consider using a dummy head\n3. Track multiple pointers if needed\n4. Watch for null pointer issues\n5. Test with edge cases (empty, single node)\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 51.8%\n- **Topics:** Linked List, Two Pointers, Stack, Recursion\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for linked list structure",
        "output": "See problem for expected output",
        "explanation": "Draw the pointer movements on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: list length, node value ranges, list can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "235",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 63.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "# Lowest Common Ancestor of a Binary Search Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 63.1%\n- **Topics:** Tree, Depth-First Search, Binary Search Tree, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "236",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "titleSlug": "lowest-common-ancestor-of-a-binary-tree",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 60.5,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "# Lowest Common Ancestor of a Binary Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 60.5%\n- **Topics:** Tree, Depth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "268",
    "title": "Missing Number",
    "titleSlug": "missing-number",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 64.3,
    "topicTags": [
      "Array",
      "Hash Table",
      "Math",
      "Bit Manipulation",
      "Sorting"
    ],
    "description": "# Missing Number\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 64.3%\n- **Topics:** Array, Hash Table, Math, Bit Manipulation, Sorting\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "295",
    "title": "Find Median from Data Stream",
    "titleSlug": "find-median-from-data-stream",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 51.8,
    "topicTags": [
      "Two Pointers",
      "Design",
      "Sorting",
      "Heap (Priority Queue)",
      "Data Stream"
    ],
    "description": "# Find Median from Data Stream\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 51.8%\n- **Topics:** Two Pointers, Design, Sorting, Heap (Priority Queue), Data Stream\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "297",
    "title": "Serialize and Deserialize Binary Tree",
    "titleSlug": "serialize-and-deserialize-binary-tree",
    "difficulty": "Hard",
    "paidOnly": false,
    "acRate": 57.2,
    "topicTags": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "description": "# Serialize and Deserialize Binary Tree\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Hard\n- **Acceptance Rate:** 57.2%\n- **Topics:** String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Hard level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "300",
    "title": "Longest Increasing Subsequence",
    "titleSlug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 54.2,
    "topicTags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "description": "# Longest Increasing Subsequence\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 54.2%\n- **Topics:** Array, Binary Search, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "347",
    "title": "Top K Frequent Elements",
    "titleSlug": "top-k-frequent-elements",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 65.1,
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "description": "# Top K Frequent Elements\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 65.1%\n- **Topics:** Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "371",
    "title": "Sum of Two Integers",
    "titleSlug": "sum-of-two-integers",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.8,
    "topicTags": [
      "Math",
      "Bit Manipulation"
    ],
    "description": "# Sum of Two Integers\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 50.8%\n- **Topics:** Math, Bit Manipulation\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "417",
    "title": "Pacific Atlantic Water Flow",
    "titleSlug": "pacific-atlantic-water-flow",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 55.1,
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "description": "# Pacific Atlantic Water Flow\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 55.1%\n- **Topics:** Array, Depth-First Search, Breadth-First Search, Matrix\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "424",
    "title": "Longest Repeating Character Replacement",
    "titleSlug": "longest-repeating-character-replacement",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 52.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "# Longest Repeating Character Replacement\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 52.9%\n- **Topics:** Hash Table, String, Sliding Window\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "435",
    "title": "Non-overlapping Intervals",
    "titleSlug": "non-overlapping-intervals",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 51.7,
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "description": "# Non-overlapping Intervals\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 51.7%\n- **Topics:** Array, Dynamic Programming, Greedy, Sorting\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "449",
    "title": "Serialize and Deserialize BST",
    "titleSlug": "serialize-and-deserialize-bst",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.7,
    "topicTags": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "# Serialize and Deserialize BST\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 58.7%\n- **Topics:** String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Search Tree, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "518",
    "title": "Coin Change II",
    "titleSlug": "coin-change-ii",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 64.8,
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "# Coin Change II\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 64.8%\n- **Topics:** Array, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "543",
    "title": "Diameter of Binary Tree",
    "titleSlug": "diameter-of-binary-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 58.1,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "# Diameter of Binary Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 58.1%\n- **Topics:** Tree, Depth-First Search, Binary Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "572",
    "title": "Subtree of Another Tree",
    "titleSlug": "subtree-of-another-tree",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 47.2,
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "String Matching",
      "Binary Tree",
      "Hash Function"
    ],
    "description": "# Subtree of Another Tree\n\nSolve this tree problem using traversal techniques and recursive thinking.\n\n**Key Concepts:**\n- Tree traversal (pre/in/post-order, level-order)\n- Recursion with base cases\n- DFS vs BFS approach\n- Parent-child relationships\n\n**Approach:**\n1. Draw the tree structure on the whiteboard\n2. Identify the base case (null node or leaf)\n3. Define what to return at each node\n4. Consider if you need helper functions\n5. Test with small examples\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 47.2%\n- **Topics:** Tree, Depth-First Search, String Matching, Binary Tree, Hash Function\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for tree structure",
        "output": "See problem for expected output",
        "explanation": "Draw the tree on the whiteboard and trace your algorithm!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common: number of nodes, node value ranges, tree can be empty",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "647",
    "title": "Palindromic Substrings",
    "titleSlug": "palindromic-substrings",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 68.3,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "# Palindromic Substrings\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 68.3%\n- **Topics:** String, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "739",
    "title": "Daily Temperatures",
    "titleSlug": "daily-temperatures",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 66.8,
    "topicTags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "# Daily Temperatures\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 66.8%\n- **Topics:** Array, Stack, Monotonic Stack\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "853",
    "title": "Car Fleet",
    "titleSlug": "car-fleet",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 50.1,
    "topicTags": [
      "Array",
      "Stack",
      "Sorting",
      "Monotonic Stack"
    ],
    "description": "# Car Fleet\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 50.1%\n- **Topics:** Array, Stack, Sorting, Monotonic Stack\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "875",
    "title": "Koko Eating Bananas",
    "titleSlug": "koko-eating-bananas",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 55.7,
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "description": "# Koko Eating Bananas\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 55.7%\n- **Topics:** Array, Binary Search\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "981",
    "title": "Time Based Key-Value Store",
    "titleSlug": "time-based-key-value-store",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 53.9,
    "topicTags": [
      "Hash Table",
      "String",
      "Binary Search",
      "Design"
    ],
    "description": "# Time Based Key-Value Store\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 53.9%\n- **Topics:** Hash Table, String, Binary Search, Design\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "1046",
    "title": "Last Stone Weight",
    "titleSlug": "last-stone-weight",
    "difficulty": "Easy",
    "paidOnly": false,
    "acRate": 65.3,
    "topicTags": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "description": "# Last Stone Weight\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Easy\n- **Acceptance Rate:** 65.3%\n- **Topics:** Array, Heap (Priority Queue)\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Easy level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "1143",
    "title": "Longest Common Subsequence",
    "titleSlug": "longest-common-subsequence",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 58.9,
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "description": "# Longest Common Subsequence\n\nWork through this string manipulation problem that tests pattern recognition and efficient string processing.\n\n**Key Concepts:**\n- String traversal (forward, backward, two pointers)\n- Character frequency counting\n- Substring patterns\n- String building vs in-place modification\n\n**Approach:**\n1. Draw out examples on the whiteboard\n2. Look for patterns or repeating structures\n3. Consider if you need a hash map for character tracking\n4. Think about time/space tradeoffs\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 58.9%\n- **Topics:** String, Dynamic Programming\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Draw the string transformations on the whiteboard!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Common constraints: string length, character types (lowercase, uppercase, alphanumeric)",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  },
  {
    "id": "1584",
    "title": "Min Cost to Connect All Points",
    "titleSlug": "min-cost-to-connect-all-points",
    "difficulty": "Medium",
    "paidOnly": false,
    "acRate": 70.5,
    "topicTags": [
      "Array",
      "Union Find",
      "Graph",
      "Minimum Spanning Tree"
    ],
    "description": "# Min Cost to Connect All Points\n\nSolve this array manipulation problem that tests your understanding of efficient iteration and data structure usage.\n\nThis problem requires you to work with array elements and apply algorithmic thinking to find the optimal solution.\n\n**Key Concepts:**\n- Array traversal and indexing\n- Pattern recognition\n- Time/space complexity optimization\n\n**Approach:**\n1. Understand the input constraints\n2. Consider edge cases (empty array, single element, etc.)\n3. Think about whether you need multiple passes\n4. Consider if sorting or hash maps could help\n\n### 📊 Problem Stats\n- **Difficulty:** Medium\n- **Acceptance Rate:** 70.5%\n- **Topics:** Array, Union Find, Graph, Minimum Spanning Tree\n\n### 🎨 Interview Tip\nUse the whiteboard to:\n- Sketch out your approach\n- Draw examples and edge cases\n- Explain your thinking to your interviewer\n- Calculate time/space complexity\n\nThis is what makes CodePair better than solo practice!",
    "examples": [
      {
        "input": "Example 1: See problem for specific examples",
        "output": "See problem for expected output",
        "explanation": "Work through examples on the whiteboard with your partner!"
      }
    ],
    "constraints": [
      "See problem for specific constraints",
      "Consider edge cases: empty input, single element, duplicates, negative numbers",
      "Work through constraints on the whiteboard with your partner",
      "This is a Medium level problem - adjust your approach accordingly"
    ]
  }
]